<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Thu Aug 21 04:43:10 EDT 2008 -->
<TITLE>
Overview (EventBus)
</TITLE>

<META NAME="date" CONTENT="2008-08-21">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (EventBus)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H1>
<h1>EventBus</h1>
</H1>
</CENTER>
The EventBus provides publish/subscribe event services for a single JVM.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/bushe/swing/event/package-summary.html">org.bushe.swing.event</A></B></TD>
<TD>The main package, provides publish/subscribe services for Swing and non-Swing applications.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/bushe/swing/event/annotation/package-summary.html">org.bushe.swing.event.annotation</A></B></TD>
<TD>EventBus annotations to make it much simpler to publish and subscribe to events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/bushe/swing/event/generics/package-summary.html">org.bushe.swing.event.generics</A></B></TD>
<TD>A class to make using generics with the EventBus possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="org/bushe/swing/exception/package-summary.html">org.bushe.swing.exception</A></B></TD>
<TD>A few classes that help in dealing with Swing Exceptions.</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<p>The EventBus provides publish/subscribe event services for a single JVM.</p>
<p>The EventBus is usable in type of any application, and has extensions and defaults to make it especially suitable for
   Swing Applications.  The pub/sub services provided by the EventBus are similar to JMS, however EventBus
   events are confined to a single JVM process. Despite the "event" name, the EventBus works for any objects of any type,
   and does not rely on special event classes.</p>

<p>The EventBus implements a decoupling paradigm that allows two components to communicate with each other without either
   of them knowing about the other (i.e., having a reference to the other).&nbsp; It is an alternative to
   the tight coupling introduced by explicit APIs such as the typical Swing addXXXListener event mechanism.&nbsp;
   When using the EventBus, events become a loose contract made between components.  Pub/sub is especially
   suitable for dynamic applications when objects that must communicate come and go.

<p>The EventBus has two styles of publish-subscibe: by a Class or by a Topic (a String).  In class-based pub/sub, any component can subcribe to
   a Class on the <A HREF="org/bushe/swing/event/EventBus.html" title="class in org.bushe.swing.event"><CODE>EventBus</CODE></A> (or any <A HREF="org/bushe/swing/event/EventService.html" title="interface in org.bushe.swing.event"><CODE>EventService</CODE></A>).  Any other component can publish an 
   object as an "event" on the EventBus.  All subscribers to the published object's Class will be notified of the object's publication.  In class-based 
   pub/sub all expected class and interface semantics, such as inheritance, are respected, including generic subtyping.  For example, an object subcribed
   to Number.class will be notified of publication of Integers and Doubles.
<p>In topic-based pub/sub, components publish objects using a String.  The String used is called the "topic", the object published
   with the String is often called the "payload."  Other objects subscribe to a topic String on the EventBus and will be notified of the
   publication on the topic and passed the payload object.  Regular expressions are supported for topic subscriptions.  For
   example, subscribing to the "F*" topic will cause notifications for "Foo" publications.</p>
<p>For Swing applications, the EventBus can largely replace hardcoded addXXXListener mechanism, particularly for
   components that are not "near" each other. The component that normally sends events to its listener list instead publishes events to the EventBus.&nbsp; The
   EventBus takes care of routing events from publishers to subscribers, obviating the need for listener management between components.  There are many
   other useful patterns implementable via the EventBus for Swing and non-Swing applications.</p>
<p>
   There are two EventService implementations provided  by the EventBus library.  One is the <A HREF="org/bushe/swing/event/ThreadSafeEventService.html" title="class in org.bushe.swing.event"><CODE>ThreadSafeEventService</CODE></A>.
   As the name implies the ThreadSafeEventService can be used in multithreaded environments.  There are no extra threads created by the EventBus,
   as notification generally happens on the publishing thread.  The exception to this rule is <A HREF="org/bushe/swing/event/SwingEventService.html" title="class in org.bushe.swing.event"><CODE>SwingEventService</CODE></A>, 
   which extends the ThreadSafeEventService and ensures that notifications of subscribers are later posted on the
   Swing/AWT <CODE>EventDispatchThread</CODE> if the publishing thread is not already the EventDispatchThread.

<p>The key class in the EventBus library is the <A HREF="org/bushe/swing/event/EventBus.html" title="class in org.bushe.swing.event"><CODE>EventBus</CODE></A>.  The EventBus is a wrapper around an EventService, by default 
         a SwingEventService.  Non-Swing applications can change the default implementation, by using the  <A HREF="org/bushe/swing/event/EventServiceLocator.html" title="class in org.bushe.swing.event"><CODE>EventServiceLocator</CODE></A>.</p>

<p>
   An application may use multiple event services.  The EventServiceLocator is a central registry of EventServices where any
   number of EventServices can be registered by name.  There is only one EventService instance created by this library and it is 
   registered by default under both the names "EventBus" and "SwingEventService".   The EventBus class wraps the EventService registered with the
   EventServiceLocator under the name "EventBus".  By default, the EventServiceLocator's "EventBus" event service is the same instance as the 
   EventService registered under the name "SwingEventService", an instance of a SwingEventService, but the instance registered under either name 
   can be changed programmatically or via Java properties before the first time they are requested from the EventServiceLocator.  Non-Swing applications 
   will want to register a <A HREF="org/bushe/swing/event/ThreadSafeEventService.html" title="class in org.bushe.swing.event"><CODE>ThreadSafeEventService</CODE></A> under the "EventBus" name.  Advanced Swing applications may also choose
   to register ThreadSafeEventServices under other names to differentiate UI and non-UI communications.
</p>

<p>See the <a href="org/bushe/swing/event/package-summary.html">org.bushe.swing.event package overview</a> for an introduction to the EventBus API.</p>

<h2>Caution</h2>
<p>
   The EventBus is intented to be very simple to use. There is no setup required for Swing applications and the API is
   fairly small. You do, however, need to be careful with memory management for subscribers. A couple of tips:
   <ul>
      <li>Never call subscribe() with an anonymous inner class - it will usually be garbage collected before it can be published to.
      </li>
      <li>When calling subscribe(), keep a reference to the subscriber for as long as you want the
         subscription to last. For example, a JPanel that adds a subscriber to the EventBus will
         usually want to keep a reference to the subscriber as an instance variable, otherwise it
         will be garbage collected right away.
      </li>
      <li>If you want to have a subscriber that lasts until the JVM exits, use subscribeStrongly().</li>
   </ul>
</p>
<h2>Two Analogies</h2>
<p>The EventBus is a different motif for Swing design that some Swing developers find
   difficult to understand at first.&nbsp; There are two analogies to the EventBus that
   may aid understanding.&nbsp; The first is messaging systems like JMS where one
   process publishes messages on a topic name to other processes.&nbsp; For example,
   a stock quote server may publish &quot;$505&quot; to a messaging system on a topic 
   named &quot;GOOG&quot;.&nbsp; Client applications may subscribe to the 
   &quot;GOOG&quot; topic on the message system and update their ticker
   when they recieve messages for &quot;GOOG&quot;.&nbsp; The JMS system decouples the
   clients from the server.&nbsp; The server code does not need to explicitly keep track of how many
   clients are active, where they are located, whether the clients are still up and
   running, which ones are interested in &quot;GOOG&quot;, etc.&nbsp; The JMS system takes
   care of the details.&nbsp; Similarly, the clients don't have to know whether the server
   is still up and running, where it located, etc.&nbsp; All you need are publish() and
   subscribe() and a good JMS implementation.</p>
<p> Another analogy is a computer motherboard system bus.&nbsp; Different components
   plug into the bus and receive and send messages to other componets on the bus.&nbsp;
   You don't need to hook your CPU directly into each component in your computer,
   nor does your video card hook up directly to your monitor.&nbsp; This layer of decoupling
   makes things a lot easier on device manufacturers, chip designers, computer
   manufacturers and computer owners.</p>
<p>The EventBus similarly solves many problems in Swing (or any appplication) by introducing this decoupling
   layer. </p>
<h2>Features</h2>
<ul>
   <li>EventService implementations are <strong>threadsafe</strong> - multiple
      threads can be publishing and subscribing at the same time.
   <li>Event Services can be used in a <strong>typesafe</strong> manner.
   <li>Multiple EventServices can be used simulanteously to properly route event traffic.
   <li>All class semantics are respected - including interfaces and generic types.
   <li>Regular expression are supported for matching topic names.
   <li>Annotations are provided that allow exceptionally terse coding.
   <li>Using the SwingEventService ensures Swing events are <strong>safely published
      on the Swing EDT</strong> when necessary.
   <li>Event Services allows <strong>veto</strong> event publication in a manner
      more safe than the JavaBeans VetoableEventListener.&nbsp; In JavaBeans, VetoableChangeSupport.fireVetoChange()
      &quot;if anyone vetos the change, then a new event [is fired] reverting everyone
      to the old value.&quot; The EventService tests all VetoableListeners <strong>first</strong>,
      and does not publish the event if any vetoable listener vetos it.&nbsp; This avoids
      having to write &quot;undo&quot; code or transactional code needed in JavaBean'
      vetoable properties.
   <li>EventServices allows easy listener management by using <strong>WeakReferences</strong> by default.
      All EventService subscribe(...) methods have a subscribeStrongly(...) siblng.&nbsp; The subscribe(...)
      methods create a WeakReference of the subscriber and subscribe the weak reference.&nbsp;
      The subscriber can then get garbage collected normally, even while subscribed.&nbsp;
      When Subscribers subscribe weakly, they do not have to worry about unsubscribing, thus avoiding memory leaks.&nbsp;
      Using the subscribeStrongly(...) methods, the subscribers must be unsubscribed, otherwise memory leaks may occur.
   <li>Events can be set up to be cached, ensuring new subscribers can as for recently published events before subscribing
        so that they are not "left out of the conversation."
   <li>EventService support for Swing Containers allows Swing components to limit event
      publication to a component and its children.&nbsp; Children can automatically subscribe
      to the Container EventService of their nearest parent through the <A HREF="org/bushe/swing/event/ContainerEventServiceRegistrar.html" title="class in org.bushe.swing.event"><CODE>ContainerEventServiceRegistrar</CODE></A>,
      even if they don't yet have a parent (or if they move).&nbsp; A parent can define
      itself the as a <A HREF="org/bushe/swing/event/ContainerEventServiceSupplier.html" title="interface in org.bushe.swing.event"><CODE>ContainerEventServiceSupplier</CODE></A>, if none are defined
      one is created on the RootPaneContainer automagically.
</ul>
<p>
   The Event Service is a centralized processor of application events local to the
   process (client).&nbsp; It does not provide any processing of events outside of the
   process.&nbsp; In other words it does not move events from a server to a client - it
   is not a solution for SOA, or any other multi-tier problem.&nbsp;
   The EventBus is not a JMS replacement, but compliments it well.  The EventService is very useful 
   as a mediator between server communications to an application and the objects in the app that
   rely on the server communication.&nbsp; Each call from the server can be published on an EventService.&nbsp; 
   Any client-side component (Swing or non-Swing) can then subscribe to the client-side event and receive 
   the updates.&nbsp; This structure automatically makes your Swing app thread-safe in the incoming direction. 
   In environments where the server provides frequent updates (say, every 2 seconds, depending on the speed of 
   your client-side processing code), you should take care to throttle updates to the Swing EDT, perhaps coalescing
   many events into one. This can be done from the server side, of course, but the multithreaded
   EventService allows this to occur client-side as well assuming sufficient processing power on the
   client for the non-EDT threads (which is typically the case).<br>
<h2> Advantages </h2>
<ul>
   <li>Using the EventService avoids code bloat for handling events.&nbsp; There is no
      need for:
      <ul>
         <li>XXXEvent classes
         <li>XXXEventListener interfaces
         <li>XXXEventListener implementation
         <li>addXXXListener methods
         <li>removeXXXListener methods
         <li>fireEventListener methods, which tend to be very buggy (they don't handle
            exceptions well, and don't fire in the expected backwards order of EventListenerList)
         <li>(if desired) XXXEvent class are not necessary, but can be used for type
            safety.
      </ul>
   <li> The Event Bus promotes loose coupling of components.&nbsp; Components can communicate
      with each other without having to find each other and add and remove listeners
      from each other at appropriate times.
   <ul>
      <li> Poor listener management is the primary cause of client &quot;loitering
         objects&quot; a.k.a. &quot;memory leaks.&quot;&nbsp; When listeners are not
         removed, the objects they refer to stay in memory, perhaps forever.
      <li>Listener management in very dynamic GUIs, such as those that use increasing popular docking
         frameworks, is very difficult and error-prone.
      <li>Loose coupling promotes unit testing.&nbsp; When components are not tied to
         each other they are easier to test independently.
      <li>Loose coupling promotes parallel development.&nbsp; Developers can describe
         the contracts between components through the APIs of the objects that are published.&nbsp; The components
         can be tested independently and then integrated.&nbsp; This is impossible with the normal
         Swing listener mechanism.&nbsp; For example, a framework component developer can work on a commoon
         progress component that subscribes to the EventBus to update its state.&nbsp; A screen developer can
         build a screen that publishes ProgressEvents - the contract.&nbsp; Both components can be created and
         tested separately and then integrated, which is difficult with standard hard-wired listeners.
      <li>The EventBus promotes component design and simple refactoring.&nbsp; In the above example, the progress
         component can be swapped out or change its location or function, without changing the screen code.&nbsp; The 
         screen can continue publishing its ProgressEvent.&nbsp; Using Swing EventListeners one or more controllers in a hierarchy
         and the components they control would normally have to be changed significantly each time the user decides they
         don't like the pretty progress bar you designed, or its location or function, etc.
      <li>The design of the EventBus promotes the creation of Swing frameworks.&nbsp; Frameworks can plug
         into the EventService to handle the cross-cutting concerns of a client through events - validation, model management,
         data refresh, etc.
      <li>Using multiple EventServices is an good method for keeping a GUI up to date with a server. Server
         updates (such as JMS messages, cache updates, database queries, etc.) can be published from the
         client's receiving thread to client-side data models in non-Swing threads (using the ThreadSafeEventService
         or directly to client-side components using the EventBus (or another SwingEventService).
   </ul>
</ul>
<h2>Usage</h2>
<p>See the <a href="package.html">package overview</a> for an introduction to the EventBus' pub/sub services.</p>
<p>More usages will soon be available on the Event Bus wiki. See the main EventBus project page at
   <a href="http://eventbus.dev.java.net">http://eventbus.dev.java.net</a> for a link to the wiki.</p>
<p>Examples of topic and class based publication is shown in the link above.  Bbelow is an example usage.&nbsp;
   One nice usage of EventBus events is closing an application.&nbsp; Typically you want to run some kind of routine
   when the user closes the application (an &quot;Are you sure?&quot; dialog, closing connections to servers, etc.).
   There are at least two places where an application is closed - the File-&gt;Exit
   menu and the JFrame's &quot;X&quot; button.&nbsp; (or alt-F4 keystrok on Windows). The menu is an ActionListener and
   JFrame uses a Window listener. You could have the window listener call doClick() on the menu or call the menu's
   action and have the menu's action perform the work. This is less than ideal OO design, but is what Swing developers
   are often stuck with.&nbsp; This gets even less elegant when another place in the application that closes the application
   say an error catching routine (an AWTExceptionHandler or similar).
   <p>
      Instead, let's make thing more elegant and easy by using the EventBus</p>
   <pre>public class JFrame {
   <code>
   public void initialize() {
   ...
   EventBus.subscribe(ApplicationClosingEvent.class, new EventSubscriber() {
       public void onEvent() {
           shutdown();
       }
   });
   ...
   }
   public void shutdown() {
      if (document.isModified()) {
          if (!userReallyWantsToShutDown()) {
             return;
          }
      }
      closeServerSocket();
      close();
   }

   private void handleWickedBadError() {
      EventBus.publish(new ApplicationClosingEvent());
   }

   private void createMenu() {
      ...
      //An aside - a good way to create menus is with the Swing Action Manager. See http://sam.dev.java.net  :-)
      //The exit menu item's action is a special EventBusAction that fires an ApplicationClosingEvent() when clicked.
      MenuItem exit = new JMenuItem(new EventBusAction() {
         protected EventServiceEvent getEventServiceEvent(ActionEvent event) {
            return new ApplicationClosingEvent();
         }
      });
      ...
   }
  </code>
   </pre>
   Perhaps that doesn't look much better than calling <code>shutdown()</code> three times, but if this code is distributed
   three different files, it gets a little nasty.  You can expose shutdown(), but then you are on your way to the
   Swing spaghetti dinner table.
   
<h2>Miscellany</h2>

<p>The EventBus has very flexible logging options.  Logging is a good tool to use to track down the source of problem.
         It's common to think - "the EventBus is not publishing right!" But it almost certainly is doing exactly what
         you told it to do.  The EventBus has numerous DEBUG logging statements to help you determine who is subscribed to what.
         The EventBus.jar can be deployed alone, in which case java.util.logging is used by default.  It can also be
         deployed with other logging systems, such as log4j, through the use of Apache Commons Logging.  If you application
         already has logging involved, the EventBus will likely just work with it.  See the Apache Commons Logging site for
         more information.  The pertinent logging name is EventService.class.getName()
   
<p>A few of exception handling classes are included in the EventBus distributions. They don't have anything
   to do with the EventBus per se, but I simply didn't want to create another project for them. :-) SwingException
   is a handy exception when invokeLater() is called since the call stack that calls the invokeLater() can be captured
   (and is captured by the SwingEventService).

   The AWTExceptionHandler can plug into Swing to provide centralized handling of exceptions. Also included is a a
   dialog that handles exceptions, including emailing exceptions and copying them to the clipboard via jdic. It is a particularly 
   handy when using the EventBus from multiple threads. When using the email feature of the dialog jdic.jar is required on the
   classpath and the associated binary (such as jdic.dll) are required in the java.library.path.  If you are not using these
   dialogs, you don't need to deploy jdic.jar with the EventBus.jar.
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Use</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
